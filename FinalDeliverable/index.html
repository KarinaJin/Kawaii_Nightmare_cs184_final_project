<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}
			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}
			figure {
				text-align: center;
			}
			img {
				display: inline-block;
			}
			body {
				font-family: 'Inter', sans-serif;
			}
			.tab-bar {
				position: fixed;
				top: 0;
				left: 0;
				right: 0;
				width: 100%;
				background-color: #ffccea;
				display: flex;
				flex-wrap: wrap;
				justify-content: space-between;
				align-items: center;
				z-index: 999;
				padding: 10px 16px;
				box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
			}
			.tab-title {
				font-weight: 600;
				font-size: 15px;
				flex-shrink: 0;
				white-space: nowrap;
				margin-right: auto;
			}
			.tab-links {
				display: flex;
				flex-wrap: wrap;
				gap: 8px;
				min-width: 0;
				overflow-x: auto;
				padding-right: 50px;
			}
			.tab-button {
				text-decoration: none;
				color: black;
				font-size: 15px;
				padding: 8px 16px;
				border: none;
				background-color: inherit;
				cursor: pointer;
				transition: background-color 0.3s;
				font-weight: 600;
				white-space: nowrap;
			}
			.tab-button:hover {
				background-color: #c77fe3a7;
			}
			.tab-button.active {
				background-color: #c274e0;
			}
            @media print {
               @page {
                 margin: 0.5in; /* Set all page margins: top, bottom, left, right */
               }
             
               body {
                 font-size: 10pt;
                 margin: 0; /* Reset body margin since @page controls the real print margin */
               }
             
               .tab-bar, nav, footer {
                 display: none;
               }
             
               .container {
                 width: 100%;
                 padding: 0;
                 margin: 0;
               }
             
               h1, h2, h3 {
                 page-break-after: avoid;
               }
             
               figure, img {
                 max-width: 100%;
                 page-break-inside: avoid;
               }
               video {
                 max-width: 50%;
                 page-break-inside: avoid;
               }
             }
             
		</style>
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Final Deliverable</title>
	</head>
	<body>
		<div class="tab-bar">
			<div class="tab-title">CS 184/284A Spring 2025 Final Project</div>
			<div class="tab-links">
				<a href="https://karinajin.github.io/Kawaii_Nightmare_cs184_final_project/Proposal/index.html" class="tab-button">Proposal</a>
				<a href="https://karinajin.github.io/Kawaii_Nightmare_cs184_final_project/Milestone/index.html" class="tab-button">Milestone</a>
				<a href="https://karinajin.github.io/Kawaii_Nightmare_cs184_final_project/FinalDeliverable/index.html" class="tab-button active">Final Deliverable</a>
			</div>
		</div>

		<div class="container">
			<h1>Team 40: Kawaii Nightmare - Horror De-Horror-fied</h1>
			<div style="text-align: center;">Team Members: Angela Marey Rodriguez, Anthea Guo, Jackie Lian, Karina Jin</div>
			<br>

			<figure>
				<iframe width="100%" height="400"
						src="https://www.youtube.com/embed/qpaObhTRcTo"
						title="Demo Video"
						frameborder="0"
						allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
						allowfullscreen>
				</iframe>
				<figcaption>Demo Video</figcaption>
			</figure>

			Link to webpage: <a href="https://karinajin.github.io/Kawaii_Nightmare_cs184_final_project/FinalDeliverable/index.html">Kawaii_Nightmare_cs184_final_project/Milestone/index.html</a><br>
			Link to demo video: <a href="https://youtu.be/qpaObhTRcTo">Demo Video</a><br>
			Link to presentation slides: <a href="https://docs.google.com/presentation/d/1zt-sbrLjKvNAveC40DWSor0WB6StELRZi2beE25_I7M/edit?slide=id.p#slide=id.p">Final Deliverable Video Slides</a><br>
			Link to presentation slides for TA: <a href="https://docs.google.com/presentation/d/1zt-sbrLjKvNAveC40DWSor0WB6StELRZi2beE25_I7M/edit?slide=id.p#slide=id.p">Final Deliverable Presentation Slides</a>

			<h2>Abstract</h2>
			<p>
				<span style="color: black;">
					Our goal for this project is to make horror games more accessible to a broader range of players. We used pixel shading and model swapping to create a less horrifying experience for the user when playing horror games. In this project, we demonstrated these effects on the classic horror game Resident Evil. Specifically, we developed toon shaders, pixel shaders, color filters, watercolor shaders, and soft blending from scratch. After this we used the FluffyQuack 5000 mod manager to implement mod swapping, swapping zombies for Carebears, Teletubbies, and Star Wars characters.
				</span>
			</p>

            <style>
                .shader-subsection {
                  padding-left: 20px;
                  margin-bottom: 24px;
                }
            </style>

			<h2>Technical approach</h2>
			<p>
                <h3>Toon Shading</h3>
                    <ul style="list-style-type: '- '; padding-left: 1.2em;">
                        <li>Boost the brightness of each pixel in the scene by multiplying a constant factor (that's greater than 1) to the base color of the pixel which is retrieved by tex2D(ReShade::BackBuffer, texcoord).rgb; where the function tex2d samples the backbuffer texture at the provided texcoord coordinates.
                        </li>
                        <li>Then we convert the RGB values into grayscale (through the 0.299 ∙ Red + 0.587 ∙ Green + 0.114 ∙ Blue formula, this formula allows us to calculate a scalar value that approximates how bright the color appears to a human viewer.) to prepare for the light quantization.</li>
                        <li>Before going into quantization, we need to modify the luminance of the current pixel if it's too dark by lerping itsluminance within a higher range
                        </li>
                        <li>Compute the quant level for this pixel then scale the color by the quant factor needed to achieve that specific quant level</li>
                        <li>Finally we use the saturate function to clamp the resulting scaled color into proper range before returning
                        </li>
                    </ul>
                <h3>
                    Pink Filter (2 modes)</h3>
                    <ul style="list-style-type: '- '; padding-left: 1.2em;">
                        <li>Convert color from RGB to HSV and then remap all hues into a narrow magenta-violet band while preserving the scene's original shading and structure to simulate a dreamy vibe compared to the original dark scene</li>
                        <li>Use pink layers where pixels with similar values (value is calculated based on our own formula = color.r * 2 * 2 * 2 + color.g * 2 * 2 +  color.b * 2; where we try to separate scenes into different levels) are assigned the same shade of pink. This creates more toon-like scenes</li>                  
                    </ul>
                <h3>
                    Pixel Shading</h3>
                    <ul style="list-style-type: '- '; padding-left: 1.2em;">
                        <li>This pixel shader applies a stylized pixelation effect that recreates the scene with lower resolution blocks while enhancing brightness and shifting the overall color tint
                        </li>
                        <li>Divide the screen space into discrete pixel blocks determined by a PixelSize parameter. For each pixel in the scene, we compute the corresponding block coordinates by flooring the screen-space UV coordinates after scaling them by the inverse of the PixelSize, then resampling from the top-left corner of each block using tex2D(screenSampler, pixelUV). This ensures that all pixels in the same block share the same sampled color, creating the signature "pixelated" effect</li>
                        <li>Next, we apply a brightness enhancement by multiplying the sampled color by a scalar value Brightness > 1, boosting the overall intensity of the image uniformly</li>
                        <li>To further stylize the image, the shader allows individual color channel boosts. Each of the red, green, and blue components can be selectively intensified with RedBoost, GreenBoost, and BlueBoost parameters respectively. These act as tint controls, allowing the user to emphasize or suppress specific color tones in the pixelated scene, creating anything from warm sun-drenched palettes to cool neon glows</li>                
                    </ul>
                <h3>
                    Edge Detection </h3>
                    <ul style="list-style-type: '- '; padding-left: 1.2em;">
                        <li>The shader begins by computing the Sobel gradient, which detects edges by measuring the intensity differences between a pixel and its neighbors in both horizontal and vertical directions. Before applying the Sobel operator, it performs optional noise reduction through a Gaussian blur using a fixed 3x3 convolution kernel. This is blended with the original color using a user-adjustable NoiseReduction parameter, and details are preserved with a DetailPreservation slider that affects how much contrast is preserved
                        </li>
                        <li>To further improve edge accuracy and visual consistency, the shader supports adaptive thresholding. This technique adjusts the edge detection sensitivity on a per-pixel basis based on local luminance contrast, effectively reducing false edges in flat or low-contrast areas. This is done by scanning a 3x3 neighborhood of the current pixel and computing the range between the brightest and darkest pixels, then modifying the EdgeThreshold accordingly</li>
                        <li>Once the grayscale gradient magnitude is computed, it is scaled by a EdgeSharpness multiplier and compared against a dynamic threshold to determine whether it's a strong edge, a weak edge, or not an edge at all. A hysteresis mechanism is used to reduce noise: strong edges are always preserved, while weak edges are only partially shown depending on proximity to stronger edges</li>
                        <li>Edges that pass the threshold are rendered in a user-specified EdgeColor and mixed with either a pure white background (edge-only mode) or the original image (overlay mode). In overlay mode, the detected edges are blended back into the scene using a EdgeOpacity parameter, allowing for subtle or bold line effects without overwhelming the scene's original visual detail</li>
                        <li>Additionally, the EdgeWidth parameter allows users to thicken or soften the edges by scaling the intensity of the result before blending</li>
                        <li>Overall, this shader enables flexible and visually appealing edge highlighting that enhances structure, gameplay clarity, or stylization depending on the context and parameter configuration</li>    
                    </ul>
                <h3>
                    Water Color Shading:</h3>
                    To achieve the intended illustrative effect, we needed to layer different shading effects together with adjustable parameters for intensity, threshold, and color that allows for full customization for users.

                <h3>Outline Edge Detection:</h3> A shader that focuses on detecting the outline and edges of each object and character within the scene. To complete our watercolor effect, we used a slightly different edge detection implementation that finds both edges that carry depth changes and color differences within the scene, soft blending effect, and a texture overlay</li>
                        <ul style="list-style-type: '-'; padding-left: 1.2em;">
                            <li>Depth Buffer: We needed to retrieve the linearized depth values of the current pixel and its 4 direct neighbors that are used within the scene to implement a simplified version of Sobel-style edge detection via ReShade::GetLinearizedDepth(uv). For our sample offsets that checked neighboring pixels on the left, right, top, and bottom parts of the scene, we then multiplied them with the size of the pixel on the screen in normalized UV coordinates texelSize and the adjustable OutlineThickness that users can change for different visual effects on the videogame. By doing so, we can calculate the differences between the neighboring pixels' depths with our center pixel, compare with our adjustable DepthThreshold, and find the edge that we need tomanipulate the outlines within our scene</li>
                            <li>Color-Based Edge Enhancement: Our shader allows a user to also detect RGB values of the current pixel being observed in the scene with its neighbors, compare with a ColorThreshold, and also marks the pixel as an edge similarly to our Depth Buffer implementation</li>
                            <li>Adjustable Thickness & Intensity: In our main function, we use this information of the edgeDepth and edgeColor to compare whether the pixel within the scene is an edge or not. We can then apply this new edge value that has been adjusted with the new outline thickness and color adjustment to our scene via a color lerp to achieve our intended outline effect</li>    
                        </ul>

                <h3>Soft Blending:</h3> After noticing that our scene appeared very intense with the strong outlines that are now added to the scene, we needed to alleviate this effect by generating a 3x3 box blur around each pixel and then blend the result of this effect into the original color like a Guassian blur. We first sample from 8 neighbors with the center pixel that we have using offset values and pixel size multiplier via texelSize, average the RGB color within our sample grid, and lerp the pixel's color, the blurred color, and the adjustable BlendStrength parameter.


                <h3>Texture:</h3> To complete the accuracy of the watercolor effect, we added a watercolor paper texture that was heavily inspired by super-continent’s implementation on GitHub. Here we used the original game image BackBuffer with the paper texture to generate an overlay. First, the paper texture needed to be adjusted with the screen size of the game by using the ratio of the buffer width and height and later using this to adjust the paper’s dimensions. Then, our shader grabs the color of our current pixel and detects if this pixel is an edge using our edge detection algorithm from before in complete an rgb conversion between our paper texture and our game scene depending on the color space that the player chooses in ReShade. The color spaces that we used included Oklab and sRGB that are unique and can manipulate our scene using different color saturation and gradient effects. Regardless of what the player chooses, we then calculate the color density using our edge value, paper color values, and adjustable parameters such as fEdgeOffset, fEdgeDensity, fPaperDensity, fDensityOffset. After this, we convert this pigment Density into RGB color and return this new pixel value with the conversion between these two layers.

                <h3>
                    Rainbow Shadows Shading:</h3> We wanted to be able to detect the shadows within the scene that bring a dark and grim atmosphere within horror games and change them to be more welcoming and cutesy by changing the colors of these shadows. The best way that we found was through rainbows (with the help of CS184 staff)!
                    <ul style="list-style-type: '- '; padding-left: 1.2em;">
                        <li>Hue to RGB Conversion: To create a dynamic rainbow color effect to dark areas of the screen, we needed to take the hue value of the current pixel and use HSL-to-RGB formula of abs(frac(h + float3(0.0, 1.0 / 3.0, 2.0 / 3.0)) * 6.0 - 3.0). What this does is offset for the R, G, B values clamp the hue to the range of 0-1 after the addition, scale and shift the hue into 0-6 range, and create a wave pattern for all RGB components for the color wheel transitions between each of the RGB channels in order to mimic the rainbow wave
                        </li>
                        <li>Shadow Threshold: After completing this rainbow effect, we then want to get the current pixel's color and the brightness of the scene using weighted RGB average formula to check if the brightness is below our customizable ShadowThreshold value</li>
                        <li>Hue Shift Speed & Rainbow Saturation: In our shader, users can adjust the speed that the rainbows shift in the game instead of being static. To do so, we used a Timer value that gets a framecount that animates the color change over time and varies across the screen space. Then we made a saturation variable that multiplies the hue we gathered from the conversion earlier with the user's requested RainbowSaturation variable</li>
                        <li>Finally, we complete a lerp over the current color, the rainbow, and its RainbowIntensity to generate our rainbow effect</li>
                    </ul>
                </li>

                <h3>
                    Model Swapping</h3>
                    <ol type="i">
                        <li>Setup</li>
                        <ul style="list-style-type: '- '; padding-left: 1.2em;">
                            <li>Install FluffyQuack 5000, target <code>RE2Demo</code>.</li>
                            <li>Download mod <code>.pak</code>, convert via OpenIV to <code>TXD/DFF</code>.</li>
                            <li>Place in <code>modmanager/RE2Demo/Mods</code>.</li>
                        </ul>
                        <li>Activation: Relaunch FluffyQuack → toggle mod and launch demo to verify.</li>
                        <li>Implementation: Hook <code>ReShade::DrawModelReplacement</code> to intercept mesh loads, remap IDs, and update <code>modelinfo.meta</code>.</li>
                    </ol>
            </p>

			<h2>Results</h2>
			<p></p>

			<h2>References</h2>
			<p></p>

			<h2>Contribution</h2>
			<p></p>
		</div>
	</body>
</html>