<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}
			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}
			figure {
				text-align: center;
			}
			img {
				display: inline-block;
			}
			body {
				font-family: 'Inter', sans-serif;
			}
			.tab-bar {
				position: fixed;
				top: 0;
				left: 0;
				right: 0;
				width: 100%;
				background-color: #ffccea;
				display: flex;
				flex-wrap: wrap;
				justify-content: space-between;
				align-items: center;
				z-index: 999;
				padding: 10px 16px;
				box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
			}
			.tab-title {
				font-weight: 600;
				font-size: 15px;
				flex-shrink: 0;
				white-space: nowrap;
				margin-right: auto;
			}
			.tab-links {
				display: flex;
				flex-wrap: wrap;
				gap: 8px;
				min-width: 0;
				overflow-x: auto;
				padding-right: 50px;
			}
			.tab-button {
				text-decoration: none;
				color: black;
				font-size: 15px;
				padding: 8px 16px;
				border: none;
				background-color: inherit;
				cursor: pointer;
				transition: background-color 0.3s;
				font-weight: 600;
				white-space: nowrap;
			}
			.tab-button:hover {
				background-color: #c77fe3a7;
			}
			.tab-button.active {
				background-color: #c274e0;
			}
            .video-cover {
                display: none;
            }
            @media print {
               @page {
                 margin: 0.5in; /* Set all page margins: top, bottom, left, right */
               }
             
               body {
                 font-size: 10pt;
                 margin: 0; /* Reset body margin since @page controls the real print margin */
               }
             
               .tab-bar, nav, footer {
                 display: none;
               }
             
               .container {
                 width: 100%;
                 padding: 0;
                 margin: 0;
               }
             
               h1, h2, h3 {
                 page-break-after: avoid;
               }
             
               figure, img {
                 max-width: 100%;
                 page-break-inside: avoid;
               }
               iframe {
                 display: none;
                }
                .video-cover {
                    display: block;
                    width: 100%;
                    height: auto;
                }
            } 
		</style>
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Final Deliverable</title>
	</head>
	<body>
		<div class="tab-bar">
			<div class="tab-title">CS 184/284A Spring 2025 Final Project</div>
			<div class="tab-links">
				<a href="https://karinajin.github.io/Kawaii_Nightmare_cs184_final_project/Proposal/index.html" class="tab-button">Proposal</a>
				<a href="https://karinajin.github.io/Kawaii_Nightmare_cs184_final_project/Milestone/index.html" class="tab-button">Milestone</a>
				<a href="https://karinajin.github.io/Kawaii_Nightmare_cs184_final_project/FinalDeliverable/index.html" class="tab-button active">Final Deliverable</a>
			</div>
		</div>

		<div class="container">
			<h1>Team 40: Kawaii Nightmare - Horror De-Horror-fied</h1>
			<div style="text-align: center;">Team Members: Angela Marey Rodriguez, Anthea Guo, Jackie Lian, Karina Jin</div>
			<br>

            <figure>
                <div class="video-wrapper">
                  <iframe width="100%" height="400"
                          src="https://www.youtube.com/embed/qpaObhTRcTo"
                          title="Demo Video"
                          frameborder="0"
                          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                          allowfullscreen>
                  </iframe>
                  <img class="video-cover" src="images/demo_cover.png" alt="Demo Video Thumbnail">
                </div>
                <figcaption>Demo Video</figcaption>
            </figure>

			Link to webpage: <a href="https://karinajin.github.io/Kawaii_Nightmare_cs184_final_project/FinalDeliverable/index.html">Kawaii_Nightmare_cs184_final_project/Milestone/index.html</a><br>
			Link to demo video: <a href="https://youtu.be/qpaObhTRcTo">Demo Video</a><br>
			Link to Final video: <a href="">Final Video</a><br>
            Link to presentation slides to Professor & Final Video: <a href="https://docs.google.com/presentation/d/1p0gFNMAr0tYsbd-ZjURzuKSC9VIAo52TIm9XTD953jw/edit?slide=id.g353dfbec284_1_18#slide=id.g353dfbec284_1_18">Final Video Slides</a><br>
			Link to presentation slides to TA: <a href="https://docs.google.com/presentation/d/1HCJrI6NC--nnVdg3tryVPdMyJ1IQj5yVcAJWxpvBsyQ/edit?slide=id.g35141b4dabd_0_5#slide=id.g35141b4dabd_0_5">Final Deliverable Presentation Slides</a>

			<h2>Abstract</h2>
			<p>
				<span style="color: black;">
					Our goal for this project is to make horror games more accessible to a broader range of players. We used pixel shading and model swapping to create a less horrifying experience for the user when playing horror games. In this project, we demonstrated these effects on the classic horror game Resident Evil. Specifically, we developed toon shaders, pixel shaders, color filters, watercolor shaders, and soft blending from scratch. After this we used the FluffyQuack 5000 mod manager to implement mod swapping, swapping zombies for Carebears, Teletubbies, and Star Wars characters.
				</span>
			</p>

            <style>
                .shader-subsection {
                  padding-left: 20px;
                  margin-bottom: 24px;
                }
            </style>

			<h2>Technical approach/Results</h2>
			<p>
                <h3>Toon Shading</h3>
                    <ul style="list-style-type: '- '; padding-left: 1.2em;">
                        <li>Boost the brightness of each pixel in the scene by multiplying a constant factor (that's greater than 1) to the base color of the pixel which is retrieved by tex2D(ReShade::BackBuffer, texcoord).rgb; where the function tex2d samples the backbuffer texture at the provided texcoord coordinates.
                        </li>
                        <li>Then we convert the RGB values into grayscale (through the 0.299 ∙ Red + 0.587 ∙ Green + 0.114 ∙ Blue formula, this formula allows us to calculate a scalar value that approximates how bright the color appears to a human viewer.) to prepare for the light quantization.</li>
                        <li>Before going into quantization, we need to modify the luminance of the current pixel if it's too dark by lerping itsluminance within a higher range
                        </li>
                        <li>Compute the quant level for this pixel then scale the color by the quant factor needed to achieve that specific quant level</li>
                        <li>Finally we use the saturate function to clamp the resulting scaled color into proper range before returning
                        </li>
                    </ul>
                
                <h3>
                    Pink Filter (2 modes)</h3>
                    <ul style="list-style-type: '- '; padding-left: 1.2em;">
                        <li>Convert color from RGB to HSV and then remap all hues into a narrow magenta-violet band while preserving the scene's original shading and structure to simulate a dreamy vibe compared to the original dark scene</li>
                        <li>Use pink layers where pixels with similar values (value is calculated based on our own formula = color.r * 2 * 2 * 2 + color.g * 2 * 2 +  color.b * 2; where we try to separate scenes into different levels) are assigned the same shade of pink. This creates more toon-like scenes</li>                  
                    </ul>
                <h3>
                    Pixel Shading</h3>
                    <ul style="list-style-type: '- '; padding-left: 1.2em;">
                        <li>This pixel shader applies a stylized pixelation effect that recreates the scene with lower resolution blocks while enhancing brightness and shifting the overall color tint
                        </li>
                        <li>Divide the screen space into discrete pixel blocks determined by a PixelSize parameter. For each pixel in the scene, we compute the corresponding block coordinates by flooring the screen-space UV coordinates after scaling them by the inverse of the PixelSize, then resampling from the top-left corner of each block using tex2D(screenSampler, pixelUV). This ensures that all pixels in the same block share the same sampled color, creating the signature "pixelated" effect</li>
                        <li>Next, we apply a brightness enhancement by multiplying the sampled color by a scalar value Brightness > 1, boosting the overall intensity of the image uniformly</li>
                        <li>To further stylize the image, the shader allows individual color channel boosts. Each of the red, green, and blue components can be selectively intensified with RedBoost, GreenBoost, and BlueBoost parameters respectively. These act as tint controls, allowing the user to emphasize or suppress specific color tones in the pixelated scene, creating anything from warm sun-drenched palettes to cool neon glows</li>                
                    </ul>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <table style="width: 100%; text-align: center; border-collapse: collapse;">
                          <tr>
                            <td style="text-align: center;">
                              <img src="images/Pixel Normal.png" width="190px"/>
                              <figcaption>Pixel shader original</figcaption>
                            </td>
                            <td style="text-align: center;">
                              <img src="images/Pixel More Red and Blue.png" width="190px"/>
                              <figcaption>+ red & blue booster</figcaption>
                            </td>
                            <td style="text-align: center;">
                                <img src="images/Pixel More Green.png" width="190px"/>
                                <figcaption>+ green booster</figcaption>
                            </td>
                            <td style="text-align: center;">
                                <img src="images/Pixel More blue.png" width="190px"/>
                                <figcaption>+ blue booster</figcaption>
                            </td>
                          </tr>
                        </table>
                    </div>
                <h3>
                    Edge Detection </h3>
                    <ul style="list-style-type: '- '; padding-left: 1.2em;">
                        <li>The shader begins by computing the Sobel gradient, which detects edges by measuring the intensity differences between a pixel and its neighbors in both horizontal and vertical directions. Before applying the Sobel operator, it performs optional noise reduction through a Gaussian blur using a fixed 3x3 convolution kernel. This is blended with the original color using a user-adjustable NoiseReduction parameter, and details are preserved with a DetailPreservation slider that affects how much contrast is preserved
                        </li>
                        <li>To further improve edge accuracy and visual consistency, the shader supports adaptive thresholding. This technique adjusts the edge detection sensitivity on a per-pixel basis based on local luminance contrast, effectively reducing false edges in flat or low-contrast areas. This is done by scanning a 3x3 neighborhood of the current pixel and computing the range between the brightest and darkest pixels, then modifying the EdgeThreshold accordingly</li>
                        <li>Once the grayscale gradient magnitude is computed, it is scaled by a EdgeSharpness multiplier and compared against a dynamic threshold to determine whether it's a strong edge, a weak edge, or not an edge at all. A hysteresis mechanism is used to reduce noise: strong edges are always preserved, while weak edges are only partially shown depending on proximity to stronger edges</li>
                        <li>Edges that pass the threshold are rendered in a user-specified EdgeColor and mixed with either a pure white background (edge-only mode) or the original image (overlay mode). In overlay mode, the detected edges are blended back into the scene using a EdgeOpacity parameter, allowing for subtle or bold line effects without overwhelming the scene's original visual detail</li>
                        <li>Additionally, the EdgeWidth parameter allows users to thicken or soften the edges by scaling the intensity of the result before blending</li>
                        <li>Overall, this shader enables flexible and visually appealing edge highlighting that enhances structure, gameplay clarity, or stylization depending on the context and parameter configuration</li>    
                    </ul>
                <h3>
                    Water Color Shading:</h3>
                    To achieve the intended illustrative effect, we needed to layer different shading effects together with adjustable parameters for intensity, threshold, and color that allows for full customization for users.
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <table style="width: 100%; text-align: center; border-collapse: collapse;">
                          <tr>
                            <td style="text-align: center;">
                              <img src="images/normal1.png" width="250px"/>
                              <figcaption>normal</figcaption>
                            </td>
                            <td style="text-align: center;">
                                <img src="images/normal2.png" width="250px"/>
                                <figcaption>normal</figcaption>
                            </td>
                          </tr>
                        </table>
                    </div>
                <h3>Outline Edge Detection:</h3> A shader that focuses on detecting the outline and edges of each object and character within the scene. To complete our watercolor effect, we used a slightly different edge detection implementation that finds both edges that carry depth changes and color differences within the scene, soft blending effect, and a texture overlay</li>
                        <ul style="list-style-type: '-'; padding-left: 1.2em;">
                            <li>Depth Buffer: We needed to retrieve the linearized depth values of the current pixel and its 4 direct neighbors that are used within the scene to implement a simplified version of Sobel-style edge detection via ReShade::GetLinearizedDepth(uv). For our sample offsets that checked neighboring pixels on the left, right, top, and bottom parts of the scene, we then multiplied them with the size of the pixel on the screen in normalized UV coordinates texelSize and the adjustable OutlineThickness that users can change for different visual effects on the videogame. By doing so, we can calculate the differences between the neighboring pixels' depths with our center pixel, compare with our adjustable DepthThreshold, and find the edge that we need tomanipulate the outlines within our scene</li>
                            <li>Color-Based Edge Enhancement: Our shader allows a user to also detect RGB values of the current pixel being observed in the scene with its neighbors, compare with a ColorThreshold, and also marks the pixel as an edge similarly to our Depth Buffer implementation</li>
                            <li>Adjustable Thickness & Intensity: In our main function, we use this information of the edgeDepth and edgeColor to compare whether the pixel within the scene is an edge or not. We can then apply this new edge value that has been adjusted with the new outline thickness and color adjustment to our scene via a color lerp to achieve our intended outline effect</li>    
                        </ul>
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <table style="width: 100%; text-align: center; border-collapse: collapse;">
                              <tr>
                                <td style="text-align: center;">
                                  <img src="images/outline1.png" width="250px"/>
                                  <figcaption>watercolor + outline</figcaption>
                                </td>
                                <td style="text-align: center;">
                                    <img src="images/outline2.png" width="250px"/>
                                    <figcaption>watercolor + normal</figcaption>
                                </td>
                              </tr>
                            </table>
                        </div>
                <h3>Soft Blending:</h3> After noticing that our scene appeared very intense with the strong outlines that are now added to the scene, we needed to alleviate this effect by generating a 3x3 box blur around each pixel and then blend the result of this effect into the original color like a Guassian blur. We first sample from 8 neighbors with the center pixel that we have using offset values and pixel size multiplier via texelSize, average the RGB color within our sample grid, and lerp the pixel's color, the blurred color, and the adjustable BlendStrength parameter.
                <div style="display: flex; flex-direction: column; align-items: center;">
                    <table style="width: 100%; text-align: center; border-collapse: collapse;">
                      <tr>
                        <td style="text-align: center;">
                          <img src="images/softblending1.png" width="250px"/>
                          <figcaption>watercolor + softblending</figcaption>
                        </td>
                        <td style="text-align: center;">
                            <img src="images/softblending2.png" width="250px"/>
                            <figcaption>watercolor + softblending</figcaption>
                        </td>
                      </tr>
                    </table>
                </div>

                <h3>Texture:</h3> To complete the accuracy of the watercolor effect, we added a watercolor paper texture that was heavily inspired by super-continent’s implementation on GitHub. Here we used the original game image BackBuffer with the paper texture to generate an overlay. First, the paper texture needed to be adjusted with the screen size of the game by using the ratio of the buffer width and height and later using this to adjust the paper’s dimensions. Then, our shader grabs the color of our current pixel and detects if this pixel is an edge using our edge detection algorithm from before in complete an rgb conversion between our paper texture and our game scene depending on the color space that the player chooses in ReShade. The color spaces that we used included Oklab and sRGB that are unique and can manipulate our scene using different color saturation and gradient effects. Regardless of what the player chooses, we then calculate the color density using our edge value, paper color values, and adjustable parameters such as fEdgeOffset, fEdgeDensity, fPaperDensity, fDensityOffset. After this, we convert this pigment Density into RGB color and return this new pixel value with the conversion between these two layers.
                <div style="display: flex; flex-direction: column; align-items: center;">
                    <table style="width: 100%; text-align: center; border-collapse: collapse;">
                      <tr>
                        <td style="text-align: center;">
                          <img src="images/texture1.png" width="250px"/>
                          <figcaption>watercolor + texture</figcaption>
                        </td>
                        <td style="text-align: center;">
                            <img src="images/texture2.png" width="250px"/>
                            <figcaption>watercolor + texture</figcaption>
                        </td>
                      </tr>
                    </table>
                </div>
                <h3>
                    Rainbow Shadows Shading:</h3> We wanted to be able to detect the shadows within the scene that bring a dark and grim atmosphere within horror games and change them to be more welcoming and cutesy by changing the colors of these shadows. The best way that we found was through rainbows (with the help of CS184 staff)!
                    <ul style="list-style-type: '- '; padding-left: 1.2em;">
                        <li>Hue to RGB Conversion: To create a dynamic rainbow color effect to dark areas of the screen, we needed to take the hue value of the current pixel and use HSL-to-RGB formula of abs(frac(h + float3(0.0, 1.0 / 3.0, 2.0 / 3.0)) * 6.0 - 3.0). What this does is offset for the R, G, B values clamp the hue to the range of 0-1 after the addition, scale and shift the hue into 0-6 range, and create a wave pattern for all RGB components for the color wheel transitions between each of the RGB channels in order to mimic the rainbow wave
                        </li>
                        <li>Shadow Threshold: After completing this rainbow effect, we then want to get the current pixel's color and the brightness of the scene using weighted RGB average formula to check if the brightness is below our customizable ShadowThreshold value</li>
                        <li>Hue Shift Speed & Rainbow Saturation: In our shader, users can adjust the speed that the rainbows shift in the game instead of being static. To do so, we used a Timer value that gets a framecount that animates the color change over time and varies across the screen space. Then we made a saturation variable that multiplies the hue we gathered from the conversion earlier with the user's requested RainbowSaturation variable</li>
                        <li>Finally, we complete a lerp over the current color, the rainbow, and its RainbowIntensity to generate our rainbow effect</li>
                    </ul>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <table style="width: 100%; text-align: center; border-collapse: collapse;">
                          <tr>
                            <td style="text-align: center;">
                              <img src="images/rainbow1_gif.gif" width="250px"/>
                              <figcaption>rainbow</figcaption>
                            </td>
                            <td style="text-align: center;">
                                <img src="images/rainbow2_gif.gif" width="250px"/>
                                <figcaption>rainbow + watercolor</figcaption>
                            </td>
                          </tr>
                        </table>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <table style="width: 100%; text-align: center; border-collapse: collapse;">
                          <tr>
                            <td style="text-align: center;">
                              <img src="images/high_high.png" width="275px"/>
                              <figcaption>high threshold & high intensity</figcaption>
                            </td>
                            <td style="text-align: center;">
                              <img src="images/medium_high.png" width="275px"/>
                              <figcaption>medium threshold & high intensity</figcaption>
                            </td>
                            <td style="text-align: center;">
                                <img src="images/low high.png" width="275px"/>
                                <figcaption>low threshold & high intensity</figcaption>
                            </td>
                          </tr>
                        </table>
                        <table style="width: 100%; text-align: center; border-collapse: collapse;">
                            <tr>
                              <td style="text-align: center;">
                                <img src="images/high_low.png" width="275px"/>
                                <figcaption>high threshold & low intensity</figcaption>
                              </td>
                              <td style="text-align: center;">
                                <img src="images/medium low.png" width="275px"/>
                                <figcaption>medium threshold & low intensity</figcaption>
                              </td>
                              <td style="text-align: center;">
                                  <img src="images/low_low.png" width="275px"/>
                                  <figcaption>low threshold & low intensity</figcaption>
                              </td>
                            </tr>
                        </table>
                    </div>
                
                <h3>
                    Vignette Shader:</h3> Our vignette shader lightens the mellow scene with a customizable color glow around the edges of a player's screen. This creates a dreamy atmosphere or an even more horrific picture depending on the player's needs (with the help of CS184 staff)!
                    <ul style="list-style-type: '- '; padding-left: 1.2em;">
                        <li>Center + Distance Calculation: Using the center float value of the screen via float2(0.5, 0.5)value, we calculate the distance of this center pixel with our current uv pixel coordinate that we are observing. Depending on the distance of our current pixel location from the center, we use ReShade's smoothstep function to generate a smooth transition from 1 to 0 as the distance changes from our user's requested Radius and Softness parameters.
                        </li>
                        <li>Vignette Color Blending: Using the vignette intensity that we calculated previously with the current pixel’s scene color and the player’s VignetteColor, we can then lerp these values together to generate our new scene with the vignette effect.</li>
                    </ul>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <table style="width: 100%; text-align: center; border-collapse: collapse;">
                          <tr>
                            <td style="text-align: center;">
                              <img src="images/normal_vignette.png" width="275px"/>
                              <figcaption>Normal</figcaption>
                            </td>
                            <td style="text-align: center;">
                              <img src="images/watercolor_vignette.png" width="275px"/>
                              <figcaption>Watercolor</figcaption>
                            </td>
                            <td style="text-align: center;">
                                <img src="images/vignette.png" width="275px"/>
                                <figcaption>Watercolor + vignette</figcaption>
                            </td>
                          </tr>
                        </table>
                    </div>
                
                <h3>
                    Model Swapping</h3>
                    <ol type="1">
                        <li>Setup</li>
                        <ul style="list-style-type: '- '; padding-left: 1.2em;">
                            <li>Install FluffyQuack 5000, target <code>RE2Demo</code>.</li>
                            <li>Download mod <code>.pak</code>, convert via OpenIV to <code>TXD/DFF</code>.</li>
                            <li>Place in <code>modmanager/RE2Demo/Mods</code>.</li>
                        </ul>
                        <li>Activation: Relaunch FluffyQuack → toggle mod and launch demo to verify.</li>
                        <li>Implementation: Hook <code>ReShade::DrawModelReplacement</code> to intercept mesh loads, remap IDs, and update <code>modelinfo.meta</code>.</li>
                    </ol>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <table style="width: 100%; text-align: center; border-collapse: collapse;">
                          <tr>
                            <td style="text-align: center;">
                              <img src="images/model1_gif.gif" width="275px"/>
                              <figcaption>high threshold & high intensity</figcaption>
                            </td>
                            <td style="text-align: center;">
                              <img src="images/model3_gif.gif" width="275px"/>
                              <figcaption>medium threshold & high intensity</figcaption>
                            </td>
                            <td style="text-align: center;">
                                <img src="images/model5_gif.gif" width="275px"/>
                                <figcaption>low threshold & high intensity</figcaption>
                            </td>
                          </tr>
                        </table>
                        <table style="width: 100%; text-align: center; border-collapse: collapse;">
                            <tr>
                              <td style="text-align: center;">
                                <img src="images/model2_gif.gif" width="275px"/>
                                <figcaption>high threshold & low intensity</figcaption>
                              </td>
                              <td style="text-align: center;">
                                <img src="images/model4_gif.gif" width="275px"/>
                                <figcaption>medium threshold & low intensity</figcaption>
                              </td>
                              <td style="text-align: center;">
                                  <img src="images/model6_gif.gif" width="275px"/>
                                  <figcaption>low threshold & low intensity</figcaption>
                              </td>
                            </tr>
                        </table>
                    </div>
            </p>

			<h2>References</h2>
			    <p>
                    <ul>
                        <li>
                          “Super-Continent/Watercolor-Shader: A ReShade Implementation of a Watercolor Effect.” <i>GitHub</i>, 2025, 
                          <a href="https://github.com/super-continent/watercolor-shader/tree/main" target="_blank">github.com/super-continent/watercolor-shader/tree/main</a>. Accessed 3 May 2025.
                        </li>
                        <li>
                          Bradley, Daniel, and Gerhard Roth. “Adaptive Thresholding Using the Integral Image.” <i>Journal of Graphics Tools</i>, vol. 12, no. 2, 2007, pp. 13–27.
                        </li>
                        <li>
                          Marr, David, and Ellen Hildreth. “Theory of Edge Detection.” <i>Proceedings of the Royal Society of London. Series B, Biological Sciences</i>, vol. 207, no. 1167, 1980, pp. 187–217.
                        </li>
                        <li>
                          ModTutorials. “How to Install Resident Evil 2 Mods in One Click.” <i>YouTube</i>, uploaded by ModTutorials, 15 Jan. 2024, 
                          <a href="https://www.youtube.com/watch?v=bELxa_FMQhw" target="_blank">https://www.youtube.com/watch?v=bELxa_FMQhw</a>
                        </li>
                        <li>
                          Panthavma's Blog. “Toon Shading Fundamentals.” <i>Panthavma’s Blog</i>, 2023, 
                          <a href="https://panthavma.com/toon-shading-fundamentals" target="_blank">panthavma.com/toon-shading-fundamentals</a>.
                        </li>
                        <li>
                          “Pixelation Effect by Downsampling.” <i>Shader Development Guide</i>, n.d., 
                          <a href="https://shaderdevguide.com/pixelation-downsampling" target="_blank">shaderdevguide.com/pixelation-downsampling</a>.
                        </li>
                        <li>
                          “Gray-Level Quantization & Posterization.” <i>Digital Image Processing Tutorial</i>, n.d., 
                          <a href="https://digitalimagetutorials.com/gray-level-quantization-posterization" target="_blank">digitalimagetutorials.com/gray-level-quantization-posterization</a>.
                        </li>
                        <li>
                          Unity Technologies. “HSV Color Adjustment in Shaders (Unity Shader Graph).” <i>Unity Learn</i>, 
                          <a href="https://unity.com/learn/shader-graph" target="_blank">unity.com/learn/shader-graph</a>.
                        </li>
                      </ul>
                </p>

			<h2>Contribution</h2>
			    <p>
                    <span style="color: black;">Angela: Worked on the watercolor shader that included an outline edge detection, soft blending, and texture effects. Completed the shader for the vignette effect and rainbow shadow generation. Helped with finding models for model swapping.</span>
                    <br><br>
                    <span style="color: black;">Anthea: Found model swapping method and completed model swap for clothes on Leon. Finished organizing report. Designed presentation.</span>
                    <br><br>
                    <span style="color: black;">Jackie: Work on the toon shader, pink filter and help with the model swapping. Also make the gif, clips, screenshot for the presentations.</span>
                    <br><br>
                    <span style="color: black;">Karina: Work on the pixel shader and the edge detections. Record and edit the demo videos. Also move content into the final web pages.</span>
                    
                </p>
		</div>
	</body>
</html>